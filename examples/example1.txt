==============================================================================
# Path Conditions Examples (from Souper testsuite)
# This file discusses the examples involving 'pc' and 'blockpc' instructions.
# Example: test/Solver/blockpc_ifelse1.ll
==============================================================================

blockpc_ifelse1.ll
------------------------------------------------------------------------------

define i32 @foo(i32 %x) {

entry:
%cmp1 = icmp eq i32 %x, 0
br i1 %cmp1, label %cond1, label %cond2

cond1:
%t10 = add nsw i32 10, %x
br label %phi

cond2:
br label %phi

phi:
%r = phi i32 [10, %cond2], [%t10, %cond1]
%cmp = icmp eq i32 %r, 10, !expected !1
%conv = zext i1 %cmp to i32
ret i32 %conv
}

!1 = !{i1 1}
------------------------------------------------------------------------------
Optimization (origin/master)

%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 0 %2 0:i1
blockpc %0 1 %2 1:i1
%3:i32 = addnsw 10:i32, %1
%4:i32 = phi %0, 10:i32, %3
%5:i1 = eq 10:i32, %4
cand %5 1:i1
------------------------------------------------------------------------------
Optimization (with DFA)

%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 1 %2 1:i1
%3:i32 = addnsw 10:i32, %1
%4:i32 = phi %0, 10:i32, %3
%5:i1 = eq 10:i32, %4
cand %5 1:i1
------------------------------------------------------------------------------
The optimization generated by Souper (with data flow function) generates blockpc for True branch
because the function: isKnownNonEqual(%1, 0:i32) returned True.
