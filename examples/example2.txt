==============================================================================
# Path Conditions Examples (from Souper testsuite)
# This file discusses the examples involving 'pc' and 'blockpc' instructions.
# Example: test/Solver/blockpc_ifelse2.ll
==============================================================================

blockpc_ifelse2.ll
------------------------------------------------------------------------------
define i32 @foo(i32 %x) {

entry:
%cmp1 = icmp eq i32 %x, 0
br i1 %cmp1, label %cond1, label %cond2

cond1:                   ; preds = %entry
%x10 = add nsw i32 10, %x
br label %phi1

cond2:                   ; preds = %entry
br label %phi1

phi1:                    ; preds = %cond1, %cond2
%r = phi i32 [10, %cond2], [%x10, %cond1]
%cmp2 = icmp eq i32 %r, 10, !expected !1
br i1 %cmp2, label %cond3, label %cond4

cond3:                   ; preds = %phi1
%cmp10 = zext i1 %cmp2 to i32
%t1 = add nsw i32 %cmp10, 0
br label %phi2

cond4:                   ; preds = %phi1
%t2 = add nsw i32 0, 1
br label %phi2

phi2:                    ; preds = %cond3, %cond4
%t3 = phi i32 [%t1, %cond3], [%t2, %cond4]
%cmp4 = icmp eq i32 %t3, 1, !expected !1
%conv = zext i1 %cmp4 to i32
ret i32 %conv
}

!1 = !{i1 1}
------------------------------------------------------------------------------
Optimization (origin/master)

; Function: foo
%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 0 %2 0:i1
blockpc %0 1 %2 1:i1
%3:i32 = addnsw 10:i32, %1
%4:i32 = phi %0, 10:i32, %3
%5:i1 = eq 10:i32, %4
cand %5 1:i1

; Function: foo
%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 0 %2 0:i1
blockpc %0 1 %2 1:i1
%3 = block 2
%4:i32 = addnsw 10:i32, %1
%5:i32 = phi %0, 10:i32, %4
%6:i1 = eq 10:i32, %5
blockpc %3 0 %6 1:i1
blockpc %3 1 %6 0:i1
%7:i32 = zext %6
%8:i32 = addnsw 0:i32, %7
%9:i32 = addnsw 0:i32, 1:i32
%10:i32 = phi %3, %8, %9
%11:i1 = eq 1:i32, %10
cand %11 1:i1
------------------------------------------------------------------------------
Optimization (with DFA)

; Function: foo
%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 1 %2 1:i1
%3:i32 = addnsw 10:i32, %1
%4:i32 = phi %0, 10:i32, %3
%5:i1 = eq 10:i32, %4
cand %5 1:i1

; Function: foo
%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 1 %2 1:i1
%3 = block 2
%4:i32 = addnsw 10:i32, %1
%5:i32 = phi %0, 10:i32, %4
%6:i1 = eq 10:i32, %5
blockpc %3 0 %6 1:i1
%7:i32 = zext %6
%8:i32 = addnsw 0:i32, %7
%9:i32 = addnsw 0:i32, 1:i32
%10:i32 = phi %3, %8, %9
%11:i1 = eq 1:i32, %10
cand %11 1:i1
------------------------------------------------------------------------------

With Data flow function, we can make a concrete decision to take true branch.
